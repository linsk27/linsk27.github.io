[{"content":"Webpack 初步接触 一、什么是 Webpack？ Webpack 是一个 静态模块打包工具，用于将多个模块、文件和资源进行打包，以便在浏览器中高效加载和运行。\n核心功能： 模块打包\n整合 JS、CSS、图片等资源，提升代码可维护性和复用性。 依赖管理\n自动解析模块依赖关系，确保正确加载顺序，降低手动管理复杂度。 代码转换与优化\n通过 Loaders 转换代码（如 ES6 → ES5），并优化输出体积。 开发支持\n支持 HMR（热更新）、Source Maps 调试、代码分割等，提升开发效率。 生态系统\n丰富的插件（Plugins）和加载器（Loaders）扩展功能。 二、Webpack 构建流程 构建过程是串行的，主要分为以下阶段：\n初始化参数\n合并配置文件与命令行参数，生成最终配置。 启动编译\n初始化 Compiler 对象，加载插件并调用 run 方法。 确定入口\n根据 entry 配置定位所有入口文件。 编译模块\n递归处理模块依赖： 调用 Loaders 转换文件内容（如编译 Sass → CSS） 解析模块依赖关系，直至所有模块处理完成。 输出资源\n将模块组合为 Chunk，生成最终文件（如 JS/CSS 文件）。 写入文件系统\n根据 output 配置输出文件到指定路径。 插件机制 Webpack 在构建生命周期广播事件（如 compile、emit），插件通过监听事件调用 API 修改输出结果。\n三、常见 Loaders Loader 功能描述 raw-loader 导入文件原始内容（如文本文件）。 file-loader 将文件输出到指定目录，返回 URL 路径。 url-loader 小于阈值的文件转为 Base64，否则调用 file-loader。 babel-loader 转换 ES6+ 代码为向后兼容的 JavaScript。 ts-loader 编译 TypeScript 为 JavaScript。 sass-loader 编译 Sass/SCSS 为 CSS。 css-loader 解析 CSS 文件中的 @import 和 url()。 style-loader 将 CSS 注入到 DOM 的 \u0026lt;style\u0026gt; 标签中。 eslint-loader 静态检查 JavaScript 代码规范。 vue-loader 处理 Vue 单文件组件（.vue）。 四、常见 Plugins Plugin 功能描述 DefinePlugin 定义全局常量（如环境变量）。 HtmlWebpackPlugin 自动生成 HTML 文件并注入资源。 MiniCssExtractPlugin 将 CSS 提取为独立文件。 UglifyJsPlugin 压缩 JavaScript 代码。 CleanWebpackPlugin 构建前清理输出目录。 WebpackBundleAnalyzer 可视化分析打包体积。 SpeedMeasurePlugin 统计各 Loader/Plugin 的构建耗时。 五、Loader 与 Plugin 的区别 特性 Loader Plugin 核心功能 转换特定类型文件（如编译 Sass）。 扩展 Webpack 功能（如代码压缩、资源注入）。 使用场景 处理单个文件的转换逻辑。 监听构建事件，执行全局操作。 配置方式 在 module.rules 中定义，按文件类型匹配。 在 plugins 数组中实例化，可传入参数。 实现原理 基于函数链式调用处理文件内容。 基于 Tapable 事件流，在生命周期钩子中干预构建。 ","date":"2025-03-21T11:49:00+08:00","image":"https://linsk27.github.io/p/0321-webpack%E5%88%9D%E6%AD%A5%E6%8E%A5%E8%A7%A6/webpack_hu_6d0aaff99a9c177.png","permalink":"https://linsk27.github.io/p/0321-webpack%E5%88%9D%E6%AD%A5%E6%8E%A5%E8%A7%A6/","title":"Webpack初步接触"},{"content":"\n低于O(n^2)的写法，使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** *原理： * 1. 遍历nums *\t2. 通过hash.has()搜索哈希表内的对应值 *\t3. 没有对应值则存入哈希表，继续下一个数据搜索哈希表内对应值 *\t4. 搜索到对应值，终止循环 * 例子：nums:[2,8,11,15,3,7] target:9 */ var twoSum = function (nums, target) { let hash = new Map() for (let i = 0; i \u0026lt; nums.length; i++) { // 首次哈希表为空，搜索不到数据 // 如果哈希表内搜索不到nums[i]对应相加数据为target的答案，则先存入哈希表，让下个循环的nums[i]进行搜索 if (!hash.has(target - nums[i])) hash.set(nums[i],i) // 哈希表搜索到答案则直接返回 else return [hash.get(target-nums[i]), i] } }; let hash = new Map(); 是 JavaScript 中使用 Map 对象创建一个哈希表（Hash Table）的写法。Map 是 ES6 引入的一种数据结构，用于存储键值对（key-value pairs），类似于普通对象（{}），但功能更强大且灵活。\n1. Map 的核心特性 特性 描述 键的类型任意 键可以是任何数据类型（对象、函数、基本类型等），而普通对象的键只能是字符串或 Symbol。 有序性 键值对的插入顺序会被保留，遍历时按插入顺序返回。 可直接获取大小 通过 hash.size 直接获取键值对数量，而普通对象需要 Object.keys(obj).length。 高性能增删查 在频繁增删键值对时，性能通常优于普通对象。 2. 基本用法 初始化与操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 创建一个空 Map let hash = new Map(); // 添加键值对：使用 set(key, value) hash.set(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;); // 键是字符串 hash.set(42, \u0026#34;Answer\u0026#34;); // 键是数字 hash.set({}, \u0026#34;empty object\u0026#34;); // 键是对象 // 获取值：使用 get(key) console.log(hash.get(\u0026#34;name\u0026#34;)); // 输出 \u0026#34;Alice\u0026#34; // 检查键是否存在：使用 has(key) console.log(hash.has(42)); // true // 删除键值对：使用 delete(key) hash.delete(42); // 清空所有键值对：使用 clear() hash.clear(); 遍历 Map 1 2 3 4 5 6 7 8 9 10 11 // 使用 for...of 遍历键值对 for (const [key, value] of hash) { console.log(key, value); } // 获取所有键：keys() console.log(hash.keys()); // 输出所有键的迭代器 // 获取所有值：values() console.log(hash.values()); // 输出所有值的迭代器 // 获取所有键值对：entries() console.log(hash.entries()); 3. 与普通对象 {} 的区别 场景 普通对象 {} Map 键的类型 仅支持字符串或 Symbol 支持任意类型（包括对象、函数等） 顺序保证 ES6 后保持插入顺序（但不绝对可靠） 严格按插入顺序遍历 大小获取 需手动计算 Object.keys(obj).length 直接通过 map.size 性能 频繁增删时性能较差 频繁增删时性能更好 继承原型链属性 可能意外继承原型链上的属性 不会继承原型链属性 4. 使用场景 需要键为复杂类型（如对象、函数）时：\n1 2 const funcKey = () =\u0026gt; {}; hash.set(funcKey, \u0026#34;Function as key\u0026#34;); 需要保持插入顺序：\n1 2 3 4 const orderedMap = new Map(); orderedMap.set(\u0026#34;second\u0026#34;, 2); orderedMap.set(\u0026#34;first\u0026#34;, 1); console.log([...orderedMap.keys()]); // [\u0026#34;second\u0026#34;, \u0026#34;first\u0026#34;] 需要高效增删操作（如缓存、临时数据存储）：\n1 2 3 const cache = new Map(); cache.set(\u0026#34;user:123\u0026#34;, { name: \u0026#34;Alice\u0026#34; }); cache.delete(\u0026#34;user:123\u0026#34;); // 快速删除 ","date":"2025-03-16T23:10:13+08:00","permalink":"https://linsk27.github.io/p/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C--%E5%93%88%E5%B8%8C%E6%96%B9%E6%B3%95/","title":"两数之和--哈希方法"},{"content":"SEO本质 解决两个匹配问题：\n内容匹配：让网站内容精准对应搜索者的真实需求（比如用户搜「如何修复冰箱不制冷」，你的网页必须提供具体解决方案，而非只介绍冰箱品牌） 技术匹配：让搜索引擎能快速理解并推荐你的内容（比如用HTML标签明确标注文章主题、确保手机端加载速度低于2秒） 优化SEO的底层逻辑 不优化的结果 优化后的效果 对应技术手段 用户搜不到你（关键词缺失） 目标关键词进入前3页 关键词研究工具（如Google Keyword Planner） 搜索引擎误判内容（技术缺陷） 爬虫高效抓取内容 优化robots.txt文件、XML网站地图 用户点开就离开（体验差） 停留时间提升50%+ 内容分段落+配图、添加目录导航 被算法判定为低质内容 获得「优质内容」权重加分 增加专业参考文献、作者资质说明 外链数量为0 获得行业权威网站推荐 制作可被引用的研究报告/工具 必须优化SEO的数学证明 设某关键词月搜索量1000次：\n第1名点击率 ≈ 35% → 350次访问/月 第6名点击率 ≈ 4.5% → 45次访问/月 排名提升5位，流量增长678% 流量价值计算（假设转化率2%，客单价$100）：\n第1名月收益：350×2%×$100 = $700 第6名月收益：45×2%×$100 = $90 SEO带来的边际收益差：$610/月 现代SEO的三个死亡红线 关键词堆砌（密度\u0026gt;2%即可能被惩罚） 忽视用户实际停留时间（Google已用屏幕停留时长替代跳出率作为核心指标） 忽略结构化数据（没有Schema标记的网页，点击率平均低37%） ","date":"2025-03-15T13:29:13+08:00","image":"https://linsk27.github.io/p/0315-%E4%BB%80%E4%B9%88%E6%98%AFseo/SEO_hu_a90e3b1c0e2e4f9b.jpeg","permalink":"https://linsk27.github.io/p/0315-%E4%BB%80%E4%B9%88%E6%98%AFseo/","title":"什么是SEO？"},{"content":"\u0026lt;link rel=\u0026quot;canonical\u0026quot; href=\u0026quot;xxxx/t\u0026quot;\u0026gt;\n主要目的：解决 重复内容（Duplicate Content） 问题，并明确告知搜索引擎哪个是页面的“规范版本”（Canonical URL）。\n1. 什么是Canonical标签？ 作用：当同一内容（页面）可通过多个不同URL访问时（例如带参数的URL、分页、移动端/PC端不同URL等），搜索引擎可能认为这些是重复内容，导致权重分散。通过 rel=\u0026quot;canonical\u0026quot; 标签，可以指定一个 规范URL，告诉搜索引擎“这个URL是主要版本，请优先收录和排名”。\n语法：\n1 \u0026lt;link rel=\u0026#34;canonical\u0026#34; href=\u0026#34;https://example.com/规范URL\u0026#34; /\u0026gt; 2. 为什么需要添加Canonical标签？ 场景举例 URL参数导致的重复内容\n例如：\nhttps://example.com/product?id=1（排序参数）\nhttps://example.com/product?id=1\u0026amp;sort=price 搜索引擎可能认为这是两个不同页面，但实际内容相同。通过设置规范URL为 https://example.com/product?id=1，可集中权重。 分页内容\n例如：\nhttps://example.com/blog?page=1\nhttps://example.com/blog?page=2 可以在分页页面中设置规范URL指向主页面（如 https://example.com/blog），或为每个分页指定各自的规范URL。 移动端与桌面端不同URL\n例如：\nhttps://m.example.com/page（移动端）\nhttps://www.example.com/page（桌面端） 可以在移动端页面添加规范标签指向桌面端URL，或反之（根据SEO策略决定）。 3. 如何正确使用Canonical标签？ 规范URL必须是可访问的：确保 href 中的URL是真实存在的、200状态码的页面。 绝对URL优先：建议使用完整URL（如 https://example.com/t），而非相对路径（/t）。 避免链轮问题：多个页面不能互相指向对方作为规范URL（例如A→B，B→A），会导致搜索引擎无法识别。 分页处理： 如果分页内容独立，每个分页应指定自己的规范URL。 如果希望集中权重到主页面，所有分页的规范URL指向主页面。 4. 与301重定向的区别 301重定向：将用户和搜索引擎永久跳转到新URL，旧URL不再存在。 适用场景：页面迁移、URL结构变更。 Canonical标签：仅提示搜索引擎规范URL，用户仍可访问原URL。 适用场景：内容相同或高度相似的多个URL需要共存（如参数化URL）。 5. 常见错误 指向非规范域名：例如将 https://example.com/t 的规范URL设为 https://otherdomain.com/t，可能导致权重流失。 忽略动态参数：若规范URL带参数，需确保参数不影响内容（如 ?utm_source=... 可保留，但排序参数需排除）。 在非HTML页面使用：如PDF、图片等非HTML文件中添加无效。 6. 验证是否生效 使用 Google Search Console 的“URL检查”工具，查看Google是否识别了规范URL。\n通过浏览器开发者工具查看页面源代码，确认标签正确添加。\n点击Ctrl+U\n7. Nuxt3举例实现方法 优化前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 步骤1:获取本地地址或.env路径(可用其他方法实现) const requestURL = useRequestURL().href??\u0026#39;\u0026#39; // 动态设置 SEO Meta 标签 useHead({ title: fit[0].seo_setting.title??\u0026#34;\u0026#34;, // 标题 meta: [ { name: \u0026#39;description\u0026#39;, content: fit[0].seo_setting.desc??\u0026#34;\u0026#34; }, // 描述 { name: \u0026#39;keywords\u0026#39;, content: fit[0].seo_setting.keyword??\u0026#39;\u0026#39; }, // 关键词 // 社交媒体优化（OpenGraph） { property: \u0026#39;og:title\u0026#39;, content: fit[0].seo_setting.title??\u0026#39;\u0026#39; }, { property: \u0026#39;og:description\u0026#39;, content: fit[0].seo_setting.desc??\u0026#39;\u0026#39; } ], link:[ {rel:\u0026#39;canonical\u0026#39;,href:requestURL} ] }); 潜在问题 useRequestURL().href的使用风险： 在 SSR（服务器端渲染） 时可能无法正确获取完整 URL（例如在静态导出或反向代理场景下）。如果 href 为空字符串，生成的 canonical 标签会变成 \u0026lt;link rel=\u0026quot;canonical\u0026quot; href=\u0026quot;\u0026quot;\u0026gt;，这会被搜索引擎视为无效或错误的规范 URL，导致 SEO 权重流失\n动态数据为空的兜底逻辑 fit[0].seo_setting.title??\u0026quot;\u0026quot; 依赖外部数据（如 API 响应），如果 fit 数组为空或字段缺失，会导致 title、description 等关键标签为空字符串，搜索引擎会认为页面信息不完整，影响排名。\n代码健壮性改进建议 确保 fit[0].seo_setting 存在且字段完整，避免渲染时崩溃.\n优化后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 获取本地地址 const requestURL = process.server ? useRequestURL().href // SSR 环境：直接获取完整 URL : window.location.href; // 客户端：使用浏览器 URL // 动态设置 SEO Meta 标签 useHead({ title: fit[0].seo_setting.title??\u0026#34;默认标题\u0026#34;, // 标题 meta: [ { name: \u0026#39;description\u0026#39;, content: fit[0].seo_setting.desc??\u0026#34;默认描述\u0026#34; }, // 描述 { name: \u0026#39;keywords\u0026#39;, content: fit[0].seo_setting.keyword??\u0026#39;默认关键词\u0026#39; }, // 关键词 // 社交媒体优化（OpenGraph） { property: \u0026#39;og:title\u0026#39;, content: fit[0].seo_setting.title??\u0026#39;默认描述\u0026#39; }, { property: \u0026#39;og:description\u0026#39;, content: fit[0].seo_setting.desc??\u0026#39;默认描述\u0026#39; } ], link:[ {rel:\u0026#39;canonical\u0026#39;,href:requestURL} ] }); 代码整体对 SEO 的价值 核心作用 ：\n通过动态设置元标签和规范链接，解决 、关键词匹配 、权重集中 、跨平台展示三大 SEO 核心问题。\n直接收益 ：\n提升搜索排名（通过标题/描述优化）、减少重复内容惩罚（通过 canonical)、增强社交传播效果（通过 OpenGraph社交媒体优化）。\n","date":"2025-03-14T13:29:13+08:00","permalink":"https://linsk27.github.io/p/seo%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5---canonical/","title":"SEO优化手段---Canonical"},{"content":"el-table中sort的常见方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const sort = async (newIndex: number, oldIndex: number) =\u0026gt; { if (newIndex === oldIndex) return; const newData = [...tableData.value.rows]; const [movedItem] = newData.splice(oldIndex, 1); newData.splice(newIndex, 0, movedItem); newData.forEach((item, index) =\u0026gt; { item.index = index; }); // Vue3 响应式更新方式 tableData.value = { ...tableData.value, rows: [...newData] // 强制替换整个数组触发更新 }; sortData.value.tag_groups = newData.map(item =\u0026gt; ({ tag_group_id: item.tag_group_id, index: item.index })); isData .value += 1; // 每次拖拽后更新 key } ","date":"2025-03-08T00:00:00Z","permalink":"https://linsk27.github.io/p/el-table%E4%B8%ADsort%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/","title":"el-table中sort(拖拽排序)的常见方法"},{"content":"模板部分 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;!--断层--\u0026gt; \u0026lt;div class=\u0026#34;tooltip-box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tooltip-arrow\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 点击复制链接 \u0026lt;/div\u0026gt; \u0026lt;!--伪类写法--\u0026gt; \u0026lt;div class=\u0026#34;copy-tooltip-box\u0026#34;\u0026gt; 点击复制链接 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Css处理部分 断层写法例子 1 2 3 4 5 6 7 8 9 10 11 .tooltip-arrow { position: absolute; /* 👉 基于父容器（.tooltip-box）定位 */ bottom: -10px; /* 👉 位于提示框下方 10px 处（负值向上移动） */ left: 50%; /* 👉 水平居中 */ transform: translateX(-50%); /* 👉 微调水平位置 */ width: 0; /* 👉 宽度为 0，通过边框生成三角形 */ height: 0; /* 👉 高度为 0 */ border-left: 8px solid transparent; /* 👉 左侧透明边框 */ border-right: 8px solid transparent; /* 👉 右侧透明边框 */ border-top: 10px solid white; /* 👉 顶部实色边框，形成箭头 */ } 使用伪类防止断层写法 推荐方法，防止黑色透明箭头和盒子交接处出现断层深色线条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 正常的样例盒子 .copy-tooltip-box { bottom: calc(100% + 14px); position: absolute; left: 50%; transform: translateX(-50%); background-color: #323233D9; /* 黑色主题 */ width: 88px; height: 28px; color: #fff; } // 伪类实现方法 .copy-tooltip-box:after { content: \u0026#34;\u0026#34;; position: absolute; top: 100%; /* 箭头位于提示框底部 */ left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid #323233D9; } ","date":"2025-03-07T00:00:00Z","image":"https://linsk27.github.io/p/%E6%82%AC%E6%B5%AE%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E7%9B%92%E5%AD%90%E7%9A%84%E5%86%99%E6%B3%95/hover_hu_8e43e58e2447932.png","permalink":"https://linsk27.github.io/p/%E6%82%AC%E6%B5%AE%E5%87%BA%E7%8E%B0%E7%AE%AD%E5%A4%B4%E7%9B%92%E5%AD%90%E7%9A%84%E5%86%99%E6%B3%95/","title":"悬浮出现箭头盒子的写法"},{"content":"推送失败，gitee仓库缺少公钥 1 git push origin lsk_dev 1 2 3 4 5 6 7 8 9 10 11 The authenticity of host \u0026#39;gitee.com (180.76.198.77)\u0026#39; can\u0026#39;t be established. ED25519 key fingerprint is SHA256:+ULzij2u99B9eWYFTw1Q4ErYG/aepHLbu96PAUCoV88. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? y Please type \u0026#39;yes\u0026#39;, \u0026#39;no\u0026#39; or the fingerprint: yes Warning: Permanently added \u0026#39;gitee.com\u0026#39; (ED25519) to the list of known hosts. git@gitee.com: Permission denied (publickey). fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 检查与自己gitee仓库连接失败，没有显示hellow 1 ssh -T git@gitee.com 1 git@gitee.com: Permission denied (publickey). 进行公钥配置 1 ssh-keygen -t rsa -C \u0026#34;14062626+linsk27@user.noreply.gitee.com\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Generating public/private rsa key pair. Enter file in which to save the key (C:\\Users\\lsk69/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\lsk69/.ssh/id_rsa Your public key has been saved in C:\\Users\\lsk69/.ssh/id_rsa.pub The key fingerprint is: SHA256:SOV+Ur+E321Pw+9NL77mSgZm6V8lc+W3LJi3rN5qXG8 14062626+linsk27@user.noreply.gitee.com The key\u0026#39;s randomart image is: +---[RSA 3072]----+ | . | | o | | . . . .| | . o . + ..| | . S B o o =| | * +o+o*o| | oo*o+==| | *+.=E*| | o+=O=+*| +----[SHA256]-----+ 获取公钥失败 1 ssh-agent -s 1 2 3 4 5 6 7 8 unable to start ssh-agent service, error :1058 \u0026gt; Fix Error **unable to start ssh-agent service, error: 1058(xxxx)** \u0026gt; \u0026gt; 1. win + R, Go To `services.msc` \u0026gt; \u0026gt; 2. Find And Check Is `OpenSSH Authentication Agent` Service Running \u0026gt; 再次运行公钥获取成功，连接成功 1 2 3 ssh-agent -s ssh -T git@gitee.com 1 Hi linsk27(@linsk27)! You\u0026#39;ve successfully authenticated, but GITEE.COM does not provide shell access. 复制公钥数据到gitee仓库的公钥（设置） 把ssh密钥添加到码云\n打开C盘–\u0026gt;用户–\u0026gt;你的用户名–\u0026gt;找到.ssh文件夹。找到id_rsa.pub（日过有多个用最新的那个），用记事本打开，复制整个文本粘贴到gitee（点头像，进入gitee设置面板，SSH设置，将复制的文本粘贴到公钥，标题会自动生成，然后点击添加，根据提示输入密码就可以了。）\n重新推送成功 1 git push origin lsk_dev 1 2 3 4 5 6 7 8 9 10 11 12 Enumerating objects: 16, done. Counting objects: 100% (16/16), done. Delta compression using up to 16 threads Compressing objects: 100% (15/15), done. Writing objects: 100% (16/16), 2.19 KiB | 2.19 MiB/s, done. Total 16 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0) remote: Powered by GITEE.COM [1.1.5] remote: Set trace flag 824c4db5 remote: Create a pull request for \u0026#39;lsk_dev\u0026#39; on Gitee by visiting: remote: https://gitee.com/larrry/competition-system/pull/new/larrry:lsk_dev...larrry:main To gitee.com:larrry/competition-system.git * [new branch] lsk_dev -\u0026gt; lsk_dev ","date":"2024-11-20T00:00:00Z","image":"https://linsk27.github.io/p/gitee%E4%BB%93%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8E%A8%E9%80%81%E9%81%87%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF/error.svg","permalink":"https://linsk27.github.io/p/gitee%E4%BB%93%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8E%A8%E9%80%81%E9%81%87%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF/","title":"gitee仓库的第一次推送遇见的错误"},{"content":"工具合集 sunshine是一个提供给moonlight进行串流的工具\nmoonlight是一个可以方便的将Windows电脑画面传输到各主流操作系统的客户端软件上的工具\n虚拟显示器可以实现屏幕扩展的工具。在这里可以与串流实现配合。\n链接：https://pan.baidu.com/s/1_zhprVgFAOsemp3jEvslsA 提取码：lrx1\n实现屏幕复制 安装与配置sunshine 点击sunshine的.exe文件进行运行安装（安装任何东西尽量不安装到系统盘）,然后右击电脑屏幕右下角的sunshine图标，点击open sunshine进入sunshine的管理界面，具体界面类似点2的图。\n先点击齿轮图形（设置），把页面设置为中文简体方便操作，记得点击保存，然后点击apply（应用），此时会自动重启sunshine程序，如果没有启动则右键右下角的sunshine图标，点击Restart。\n同第2点开设置后，点击network板块，根据图片设置UPnP为“启用”，设置ip地址族为“IPv4+IPv6”，这个对后面串流有用。最后把公网加密模式设置为“禁用”，点击保存并且应用，重启sunshine步骤。 安装与配置moonlight 该演示为安卓端，pc端大同小异，同样可看下面教程\n在上面给的网盘内直接安装或者谷歌商店安装moonlight,进入moonlight界面 点击齿轮图形（设置），可以根据自己设备的分辨率进行设置，其中码率对远程串流会有较大影响，个人认为局域网连接可以直接拉满 设备通常打开moonlight后，在相同局域网下，设备会显示同个局域网下的电脑设备，如第一点的图所示。此时可以平板直接点击电脑设备进行连接，然后会出现ping码，通常电脑会出现ping码弹窗，没有的话打开sunshine控制台，点击ping选项进行输入。通常第一次连接之后，只要平板不删除电脑设备，就不会再要求输入ping码。 如果没有显示电脑设备，则可在电脑按下Win+R,输入cmd打开终端，然后输入ipconfig来获取局域网的ipv4或ipv6的地址（我这个网络没有ipv6地址）。然后选择字段为IPv4地址或IPv6 地址的字样才有效。ipv6对远程串流帮助较大。\n然后点击平板端的moonlight，点击加号图标，直接输入ipv4或者ipv6地址，即可显示电脑设备。\n这个时候你的平板设备应该就成功复制了电脑屏幕，并且几乎只有100ms的延迟！ 实现屏幕扩展 配置与安装ParsecVDisplay（虚拟显示器） 在网盘内或者自行选择下载虚拟显示器软件，打开后如图。 点击ADD DISPLAY,添加虚拟显示器，随后点击显示器查看属性。但是通常会有bug，比如显示\\\\.\\DISPLAY1,说明添加与原屏幕冲突，需要再添加一次，然后可以点击这个1的屏幕然后进行删除。 有正确的显示器之后，点击显示器查看显示器参数，如图为\\\\.\\DISPLAY11。同时，对该虚拟显示器的刷新率和帧率参数进行配置。最后点击CUSTOM按键，输入这些参数。 最后打开sunshine控制台，点击齿轮设置，打开video选项，输入显示器的名称\\\\.\\DISPLAY11，点击保存并且应用，然后平板进行moonlight重连，这个时候，就会扩展成功！ 打开Win+I打开电脑设置，进入“显示”模块，对平板显示器进行位置调动，方便扩展。 注意！！！不断连不上可查看此处 当时搞完这个扩展显示器，后面我出现很多次连不上的现象\n失败原因： sunshine设置了video的显示器名称后，就只会抓取该名称的显示器进行显示，如果没有生成该虚拟显示器，则其他设备的moonlight就无法链接到电脑设备\n解决方法： 方式1：把sunshine的video选项里的video清空，这样就会默认复制屏幕。\n方式2：打开虚拟显示器并且创建，保持sunshine的video设置和虚拟显示器的名称设置相同即可！！\n实现远程串流 ","date":"2024-11-02T00:00:00Z","image":"https://linsk27.github.io/p/moonlight-sunshine%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E5%B1%8F%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/moonlight_hu_cc6493ee2a05def4.jpg","permalink":"https://linsk27.github.io/p/moonlight-sunshine%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E5%B1%8F%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/","title":"moonlight+sunshine实现扩展屏和远程串流"},{"content":"什么是防抖（Debounce）？ 防抖 （多次触发 只执行最后一次） 原理：在高频率触发某个响应事件时，在规定时间间隔内如果没有再次触发，则属于最后一次完成交互，触发相对应的方法\n常用：在用户输入搜索词的过程中，每一次输入都会触发 input 事件，但显然没必要每次都发送请求，只有当用户停止输入后，系统才发送一次最终的请求\n手搓代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 1.封装防抖函数 function debounce(fn, time) { // 4.创建一个标记用来存放定时器的返回值 let timeout = null; return function () { // 5.每当用户触发input事件 把前一个 setTimeout 清楚掉 clearTimeout(timeout); // 6.然后又创建一个新的 setTimeout, 这样就能保证输入字符后等待的间隔内 还有字符输入的话，就不会执行 setTimeout里面的内容 timeout = setTimeout(() =\u0026gt; { // 7.这里进行防抖的内容 fn(); }, time); }; } // 2.获取inpt元素 var inp = document.getElementById(\u0026#34;inp\u0026#34;); // 8. 测试防抖临时使用的函数 function sayHi() { console.log(\u0026#34;防抖成功\u0026#34;); } // 3.给inp绑定input事件 调用封装的防抖函数 传入要执行的内容与间隔事件 inp.addEventListener(\u0026#34;input\u0026#34;, debounce(sayHi, 5000)); 什么是节流（Throttle）？ 节流 （时间间隔内 只允许执行一次） 原理：在高频率触发某个有响应方法的事件时，第一次触发响应事件，计时器开始计时，规定时间内继续交互不触发事件\n常用：鼠标滚轮滑动触发下拉刷新、王者的英雄技能刷新\n手搓代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 1.封装节流函数 function throttle(fn, time) { //3. 通过闭包保存一个 \u0026#34;节流阀\u0026#34; 默认为false let temp = false; return function () { //8.触发事件被调用 判断\u0026#34;节流阀\u0026#34; 是否为true 如果为true就直接trurn出去不做任何操作 if (temp) { return; } else { //4. 如果节流阀为false 立即将节流阀设置为true temp = true; //节流阀设置为true //5. 开启定时器 setTimeout(() =\u0026gt; { //6. 将外部传入的函数的执行放在setTimeout中 fn.apply(this, arguments); //7. 最后在setTimeout执行完毕后再把标记\u0026#39;节流阀\u0026#39;为false(关键) 表示可以执行下一次循环了。当定时器没有执行的时候标记永远是true，在开头被return掉 temp = false; }, time); } }; } function sayHi(e) { // 打印当前 document 的宽高 console.log(e.target.innerWidth, e.target.innerHeight); } // 2.绑定事件，绑定时就调用节流函数 // 敲黑板！！！ 这里是重点 绑定是就要调用一下封装的节流函数 触发事件是触发封装函数内部的函数 window.addEventListener(\u0026#34;resize\u0026#34;, throttle(sayHi, 2000)); 高效方式实现防抖和节流 使用 Loadash 库实现防抖和节流 lodash 是一个留下的 JavaScript 实用工具库，提供了高效的防抖和节流函数 使用步骤 安装 lodash 1 npm install lodash 使用防抖和节流 1 2 3 4 5 6 7 8 9 10 import debounce from \u0026#34;lodash/debounce\u0026#34;; import throttle from \u0026#34;lodash/throttle\u0026#34;; // 防抖示例 const debouncedSearch = debounce(handleSearch, 300); searchInput.addEventListener(\u0026#34;input\u0026#34;, debouncedSearch); // 节流示例 const throttledScroll = throttle(handleScroll, 200); window.addEventListener(\u0026#34;scroll\u0026#34;, throttledScroll); 设置合适的时间间隔 防抖和节流的核心在于事件频率控制，因此根据实际场景合理设置时间参数非常关键。过长的延迟可能导致响应不及时，而过短的间隔可能会影响性能提升效果。 通常，防抖的延迟在200ms到500ms之间，节流的时间间隔在100ms到300ms之间。\n","date":"2024-10-26T00:00:00Z","permalink":"https://linsk27.github.io/p/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8E%BB%E7%94%A8/","title":"什么是防抖和节流？什么时候去用？"},{"content":"作为一个入门程序员 大学程序员大多依靠网络上的教学视频进行学习，但这往往效率较慢，知识面也相对局限。因此，多关注优秀的博客文章、浏览有趣的论坛，并养成阅读书籍的习惯才是重中之重！\n计算机网络基础 图解 TCP/IP 图解 HTTP 算法和数据结构 算法图解 数据库 MySQL 基本操作 Linux 穷佐罗的 Linux 图书 中国科技大学的 Linux 图书 同时，以下这些网站对学习也有帮助：\n菜鸟教程: 适合入门、学习基础的网站 稀土掘金: 程序员社区交流网站，比 CSDN 更好，类似的还有 博客园 和 51CTO CSDN: 虽然口碑不佳，但偶尔可以在其中找到解决方法 怎么学前端？ 在学习前端的初期，主要关注以下内容：\n页面构建：使用 HTML、CSS 等技术构建页面的基本结构和样式。 交互实现：通过 JavaScript 等技术实现用户与页面的交互功能，如按钮点击、表单提交等。 初期掌握好前端三件套（HTML、CSS、JavaScript）是必不可少的。在写代码的过程中，将页面想象为一个个盒子，对学习前端大有裨益！\n工具\n在线调试代码: Playground | MDN 合集教学\n官方详细文档：MDN HTML 基础 这个也不错，更易懂：千古图文教程 css\nCSS 教程 JavaScript\nJavaScript 指南 个人新手推荐（有运行实例）：现代 JavaScript 教程 趣味实战 在视频和文章学习后，可以通过一些挑战或游戏来巩固所学知识：\nFlexbox 弹性布局青蛙小游戏 50 Projects in 50 Days Vue.js 挑战 工具 程序员不仅要会编程，还要会使用各种工具：\nMarkdown Markdown 是一种轻量级的标记语言，程序员必不可少的文档工具。语法简单明了，掌握后可以帮助程序员更快速地编写文档、博客和笔记。\nVS Code VS Code 拥有强大的插件生态系统，可以安装不同的插件来增强功能，适用于各种编程语言的开发。对于前端开发者来说，VS Code 提供了丰富的语言支持（如 HTML、CSS、JavaScript 等）以及大量实用插件，如代码片段、自动补全和 Git 控制等。\n版本控制工具 Git Git 是目前最流行的分布式版本控制系统，具有高效的分支管理和合并功能，支持大型项目的开发与维护。使用 Git，程序员可以进行代码的提交、拉取、推送等操作，同时方便地查看代码历史记录和比较不同版本之间的差异。\n例如，可以从 GitHub 仓库中 clone 项目文件，再通过相关 Git 命令连接该项目仓库，创建自己的分支后，使用拉取、合并等 Git 命令将自己的分支版本上传到远程仓库，实现项目互联。 ","date":"2024-10-20T00:00:00Z","permalink":"https://linsk27.github.io/p/%E5%85%A5%E9%97%A8%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%91%E8%B5%B0%E5%BC%AF%E8%B7%AF/","title":"入门前端？如何少走弯路！！！"},{"content":"修改站点背景颜色 在\u0026quot;assets/scss/variables.scss\u0026quot;中找到 1 --body-background: #f6f6f6; 或在\u0026quot;assets/scss/customs.scss\u0026quot;中找到 1 --body-background: #f6f6f6; 参考自：Hugo | Hugo-stack-theme 主题魔改版\n友链的添加 在\u0026quot;content/page/links\u0026quot;的 index.md 中有详细解释，图标可通过图床或者本地渲染，模仿格式即可，或可直接把文件内容换为 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- title: 友情链接 links: - title: 爱吃鱼的小林 - linsk description: 一个大三程序员,博客讲述了hugo中许多美化stack的主题的教程、前端领域知识以及其他 website: https://linsk27.github.io/ image: fish.png menu: main: weight: -50 params: icon: link comments: false --- 显示文章更新时间 手动添加更新时间 hugo 默认位置为 archetypes/default.md 或者主题下目录下 xx 主题/archetypes/posts.md，加lastmod字段，在创建文章模板里添加以下一行，创建时会以主题目录下的模板来创建。 1 lastmod: { { .Date } } 添加lastmod，有个好处就是可自由修改这个字段的时间。 在 \u0026ldquo;config.toml/yaml/json/\u0026rdquo; 中写明调整这里顺序即可 1 frontmatter: lastmod = [\u0026#34;:git\u0026#34;, \u0026#34;lastmod\u0026#34;, \u0026#34;:fileModTime\u0026#34;, \u0026#34;:defalut\u0026#34;] 自动添加更新时间 记得在\u0026quot;config.toml/yaml/json\u0026quot;开启 gitinfo 1 2 #获取git信息 enableGitInfo = true #设为true 这样就提交代码时，就会去读取 git 时间，来更新文章的更新时间! 但是后面我发现了一个问题：每次重新 git push 之后所有文件最近更新时间 mtime 都变成推送的时刻，这是 git 的一个部署配置问题,因此我搜索了许多博客，终于在hugo github action|vecel 部署后文章更新时间异常修复这篇文章找到了解决方法，总的来说：\n在 \u0026ldquo;.github/workflows/xx.yml\u0026rdquo;,新增以下配置，主要是quotePath，默认情况下，文件名包含中文时，git 会使用引号吧文件名括起来，这会导致 action 中无法读取:GitInfo 变量，所以要设置Disable quotePath 1 2 3 4 5 6 - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false 使用checkout的话 fetch-depth 需要设为 0，depth默认是为 1，默认只拉取分支最近一次 commit，可能会导致一些文章的 GitInfo 变量无法获取，设为 0 代表拉去所有分支所有提交。 1 2 3 uses: actions/checkout@v4 with: fetch-depth: 0 #设为0 以下是我的最终的 yml 配置文件,大家可以参考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest env: TZ: Asia/Shanghai # 添加正确的时区 steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.TOKEN }} EXTERNAL_REPOSITORY: linsk27/linsk27.github.io PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 更新时间显示在卡片 stack 主题的文章更新时间在文章底部 若想在文章开头就显示更新时间，修改 \u0026ldquo;layouts/partials/article/components/detail.html\u0026rdquo;，在指定位置引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 这样就会文章开头显示修改时间 显示文章字数统计 在\u0026quot;config.toml/yaml/json\u0026quot;的.params.article中，添加 1 wordCount: true #打开字数统计 注意的是默认 WordCount 是不统计中文字数的，你需要在\u0026quot;config.toml/yaml/json\u0026quot;中添加 1 hasCJKLanguage: true 在\u0026quot;layouts/partials/article/components/details.html\u0026quot;中的 \u0026lt;footer class=\u0026quot;article-time\u0026quot;\u0026gt;内，打开本地 hugo 静态调试，按照位置添加 1 2 \u0026lt;i class=\u0026#34;fa fa-regular fa-message\u0026#34; style=\u0026#34;color: #ff8e2d;\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 本文有 {{ .WordCount }} 个字 效果如图 修改分类标签的颜色 在\u0026quot;content/categories\u0026quot;创建与分类同名的文件夹，并且在文件夹中创建\u0026quot;_index.md\u0026quot;文件并添加下面的内容,文件内会有一个 Test 的例子，可以模仿 Test 文件夹里面的内容 1 2 3 4 5 6 7 8 ---- title: 这里写分类名称 description: 分类简介，不需要可以删了 image: \u0026#34;categories.png\u0026#34; // 分类的题图 style: background: \u0026#34;#80aba9\u0026#34; //分类标签底色 color: \u0026#34;#fff\u0026#34; ---- 背景脚本放置位置 dev\\themes\\hugo-theme-stack\\layouts\\partials\\footer ","date":"2024-10-19T00:00:00Z","image":"https://linsk27.github.io/p/hugo%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/hugo_hu_a06c8814bf2a76fe.jpg","permalink":"https://linsk27.github.io/p/hugo%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/","title":"【Hugo】主题美化教程"},{"content":" nexus 下载安装 nuxes 下载链接\n链接：https://pan.baidu.com/s/1M-cotx78rZfoPAqLzMquGA 提取码：ogh0 1.点击.exe 文件进行安装后显示 2.任务栏透明（可以都去实现）\n方式一：安装 translucenTtb​ 插件\n方式二：在设置设置任务栏自动隐藏图标\n将桌面的图标都隐藏\n进行 nexus 配置（不做过多的图片解释，可以自己一边调试一边研究，找出自己最爱的风格） 1.点击 nexus 任务栏的 nexus 打开软件\n2.点击位置将停靠设置在底部，并且根据自己的喜好进行偏移参数调整后点击应用\n3.点击“行为”,打开 dock 透明度，将 dock 透明度拉满\n4.点击“效果”，把悬浮之类的效果都可以设置为弹跳，同时设置水波纹效果等\n5. 点击“一般”，勾选隐藏系统任务栏(可勾可不勾)，勾选右下角操作栏消失\n图标的添加 1.右键 nuxes 的自带图标，将没用的图标删除\n2.右键 nexes 的自带 win 图标，点击创建 dock 项目\n3.点击查找，获取对应需要的软件 exe 文件后会自动完善信息，点击确定即可\n4.配置完成\n添加音频条和时钟组件 日后出更新以及教程噢~~ 恭喜你完成本文教程，最终配置效果如封面图，可以通过 wallpaper 找个动态壁纸，制作属于自己好看的桌面！ ","date":"2024-10-15T00:00:00Z","image":"https://linsk27.github.io/p/nexus%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/nexus6_hu_9c650a811a642bf0.png","permalink":"https://linsk27.github.io/p/nexus%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/","title":"【Nexus】桌面美化教程"},{"content":"数组去重方法 1. 通过 filter 过滤函数 JavaScript 的 Array.prototype.filter() 方法可以创建一个新数组，其包含通过所提供函数实现的测试的所有元素。利用这个特性，我们可以对数组进行去重。\n1 2 3 4 5 const array = [1, 2, 2, 3, 4, 4, 5]; const uniqueArray = array.filter((item, index, self) =\u0026gt; { return self.indexOf(item) === index; }); console.log(uniqueArray); // 输出: [1, 2, 3, 4, 5] 2. 通过 new Set() 集合进行去重 Set 是 ES6 引入的一种新的数据结构，它类似于数组，但是成员的值都是唯一的，没有重复的值。我们可以利用这个特性进行数组去重。\n1 2 3 const array = [1, 2, 2, 3, 4, 4, 5]; const uniqueArray = [...new Set(array)]; console.log(uniqueArray); // 输出: [1, 2, 3, 4, 5] 3. for 循环遍历判断 虽然 filter 和 Set 是更现代且效率更高的方法，但了解如何使用 for 循环进行去重也很有用。\n1 2 3 4 5 6 7 8 const array = [1, 2, 2, 3, 4, 4, 5]; const uniqueArray = []; for (let i = 0; i \u0026lt; array.length; i++) { if (uniqueArray.indexOf(array[i]) === -1) { uniqueArray.push(array[i]); } } console.log(uniqueArray); // 输出: [1, 2, 3, 4, 5] ","date":"2024-10-14T00:00:00Z","permalink":"https://linsk27.github.io/p/js%E4%B8%AD%E6%95%B0%E7%BB%84%E5%8E%BB%E7%9A%84%E5%B8%B8%E8%A7%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/","title":"js中数组去的常规去重方法"},{"content":" 该文章图片从网上摘录 对linux的初步准备 1.下载最新版ubuntu和UltraISo、DiskGenius工具 ubuntu下载链接：(https://cn.ubuntu.com/download/desktop)\nUltraISo、DiskGenius下载链接：（https://pan.baidu.com/s/17AwjX2AO7E5fHjYWQmINPQ）提取码：7777\n2.进行u盘刻录 插入自备u盘，注！！！u盘进行录入时会覆盖所有u盘数据\n(1).解压并打开ULtralSo，输入注册名【Guanjiu】，输入注册码【A06C-83A7-701D-6CFC】，点击【确定】\n(2).点击【文件】\n(3).点击【打开】\n(4).选中打开下载好的ubuntu.iso\n(5).点击【写入硬盘映像】\n(6).点击【写入】,选择确定继续操作\n(7).u盘刻录成功\n进行磁盘分区 1.解压并且打开DiskGenius分盘工具 （本人由于磁盘管理器无法分盘所以使用了第三方分盘工具）\n(1).鼠标右击一个磁盘（容量大的）,选择【新建分区】\n(2).所分配的新分区不少于20g，点击【开始】\n(3).点击【是】\n(4).点击【完成】\n开始安装系统 1.系统安装（由于安装时没有进行截图，这里的图片摘录自网上 (1).重启电脑，并且在开机画面出现后按本机电脑的【快捷键】（各品牌电脑的启动选择不一样，我的电脑是华硕，点击【ESC】按键）进入启动选择界面\n(2).点击UEFI选项即选择自己的u盘介质\n(3).进入后我这里选择的是第一项【尝试或者安装ubantu】，然后进入安装界面\n(4).选择中文并且安装Ubuntu\n(5).选择chinese后，点击【继续】\n(6).点击【继续】\n(7).选择【其他选项】\n(8).到这个时候会有两种情况，\n第一种是“这台计算机似乎没有安装操作系统”，此时说明为单系统刷机，点击【继续】即可，本文讲的是双系统安装\n第二种是双系统安装，此时会进入分盘界面，选择空闲磁盘进行四次分区\n(9)分区完成后点击【现在安装】，点击【继续】\n(10)输入用户名密码即可开始等待安装\n(11)安装完成后重启\n2.完成安装 (1)重启后，每次开机时会出现三个选项，点击ubuntu进入ubuntu系统，点击win回到原系统\n(2)输入密码进入用户界面\n","date":"2024-10-14T00:00:00Z","permalink":"https://linsk27.github.io/p/linux%E7%9A%84%E5%AE%89%E8%A3%85ubuntu/","title":"Linux的安装（Ubuntu）"},{"content":"一 使用方法 userList数据循环在列表，下拉框显示的值为userList里面的label字段的值，实际值为对应label的uuid值，如下面例子中输出选中小王的值应该为01\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;el-select v-model=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;el-option v-for=\u0026#34;item in userList\u0026#34; :key=\u0026#34;item.uuid\u0026#34; :label=\u0026#34;item.username\u0026#34; :value=\u0026#34;item.uuid\u0026#34; /\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/template\u0026gt; 1 2 3 4 5 const userList = ref([{ username:\u0026#39;小王\u0026#39;, uuid:\u0026#39;01\u0026#39; }]) const form = ref\u0026lt;any\u0026gt;() 二 传值问题（匹配功能） 当我们在子组件进行表单操作的时候，需要从父组件往子组件传相关操作数据的值，若传入form的值是小王，则form在下拉框中显示的值为小王,实际值也为小王，若传入的值为01,则下拉框中显示的值为小王，实际值依旧为01\n","date":"2024-10-13T00:00:00Z","permalink":"https://linsk27.github.io/p/el-select%E6%A0%87%E7%AD%BE%E5%AD%98%E5%9C%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/","title":"el-select标签存在的数据匹配问题"},{"content":"[vue/no-use-v-if-with-v-for] 这个错误信息是由 ESLint 的 Vue.js 插件 eslint-plugin-vue 产生的。它指出在你的 Vue.js 模板中，v-if 和 v-for 指令被不当地一起使用在了同一个元素上。\n为什么会产生这个错误？ 在 Vue.js 中，当 v-if 和 v-for 同时用在同一个元素上时，Vue 会先处理 v-for，然后处理 v-if。这意味着即使 v-if 最终会过滤掉一些元素，v-for 仍然会遍历整个列表，这可能会导致不必要的计算开销，特别是在处理大型列表时。\n如何修复这个错误？ 根据 ESLint 的建议，你应该将 v-if 移动到包含 v-for 的父元素（或“包装元素”）上。这样可以确保 v-if 的条件判断只执行一次，而不是对 v-for 生成的每个元素都执行。\n错误的示例： 1 2 3 \u0026lt;div v-for=\u0026#34;item in items\u0026#34; v-if=\u0026#34;item.active\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/div\u0026gt; 在这个例子中，v-if 会在每次迭代时都执行，检查 item.active 是否为真。\n正确的示例： 1 2 3 4 5 \u0026lt;div v-if=\u0026#34;hasActiveItems\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;item in activeItems\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{ item.name }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 在这个修正后的例子中，首先通过一个计算属性 hasActiveItems 或在 data、computed 或 methods 中定义的逻辑来检查是否有活跃的项。如果有，则使用 v-for 来渲染这些活跃的项。这里的 activeItems 应该是一个只包含活跃项的数组。\n总结 通过将 v-if 移动到 v-for 的外部，你可以优化你的 Vue 组件的性能，避免不必要的渲染和计算。这也是 Vue.js 官方文档和 ESLint 插件推荐的最佳实践。\n","date":"2024-10-12T00:00:00Z","permalink":"https://linsk27.github.io/p/v-if%E5%92%8Cv-for%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%AF%A5%E5%90%8C%E6%97%B6%E4%BD%9C%E7%94%A8%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97/","title":"v-if和v-for为何不该同时作用于一个模块？"}]